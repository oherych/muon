package muon

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
)

type G string

var (
	testString = "test"

	tests = map[string]struct {
		golang  interface{}
		encoded []byte
		tokens  []Token
	}{
		"nil": {
			golang:  nil,
			encoded: []byte{nilValue},
			tokens:  []Token{{A: tokenNil}},
		},
		"string_empty": {
			golang:  "",
			encoded: []byte{stringEnd},
			tokens:  []Token{{A: TokenString, Data: ""}},
		},
		"string": {
			golang:  testString,
			encoded: []byte{0x74, 0x65, 0x73, 0x74, stringEnd},
			tokens:  []Token{{A: TokenString, Data: testString}},
		},
		"string_with_zero": {
			golang:  "te" + string([]byte{stringEnd}) + "st",
			encoded: []byte{stringStart, 0x74, 0x65, 0x0, 0x73, 0x74},
			tokens:  []Token{{A: TokenString, Data: "te" + string([]byte{stringEnd}) + "st"}},
		},
		"long_string": {
			golang:  "test Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce mi mauris, fringilla a gravida ac, vulputate vitae dui. Proin rhoncus ante vitae purus mollis, id hendrerit tellus tempor. Aliquam ut ex nibh. Aenean quis quam eu purus scelerisque viverra ac consequat justo. Sed lobortis interdum facilisis. Sed euismod est magna, at iaculis nisi mollis a. Maecenas nec diam augue. Phasellus volutpat mattis nisi, eu sagittis enim tempor vitae. Aliquam sit amet ante finibus, bibendum lorem et, porta libero. Sed eu.",
			encoded: []byte{stringStart, 0x74, 0x65, 0x73, 0x74, 0x20, 0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x2e, 0x20, 0x46, 0x75, 0x73, 0x63, 0x65, 0x20, 0x6d, 0x69, 0x20, 0x6d, 0x61, 0x75, 0x72, 0x69, 0x73, 0x2c, 0x20, 0x66, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6c, 0x6c, 0x61, 0x20, 0x61, 0x20, 0x67, 0x72, 0x61, 0x76, 0x69, 0x64, 0x61, 0x20, 0x61, 0x63, 0x2c, 0x20, 0x76, 0x75, 0x6c, 0x70, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x76, 0x69, 0x74, 0x61, 0x65, 0x20, 0x64, 0x75, 0x69, 0x2e, 0x20, 0x50, 0x72, 0x6f, 0x69, 0x6e, 0x20, 0x72, 0x68, 0x6f, 0x6e, 0x63, 0x75, 0x73, 0x20, 0x61, 0x6e, 0x74, 0x65, 0x20, 0x76, 0x69, 0x74, 0x61, 0x65, 0x20, 0x70, 0x75, 0x72, 0x75, 0x73, 0x20, 0x6d, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x2c, 0x20, 0x69, 0x64, 0x20, 0x68, 0x65, 0x6e, 0x64, 0x72, 0x65, 0x72, 0x69, 0x74, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x75, 0x73, 0x20, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x2e, 0x20, 0x41, 0x6c, 0x69, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x75, 0x74, 0x20, 0x65, 0x78, 0x20, 0x6e, 0x69, 0x62, 0x68, 0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61, 0x6e, 0x20, 0x71, 0x75, 0x69, 0x73, 0x20, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x65, 0x75, 0x20, 0x70, 0x75, 0x72, 0x75, 0x73, 0x20, 0x73, 0x63, 0x65, 0x6c, 0x65, 0x72, 0x69, 0x73, 0x71, 0x75, 0x65, 0x20, 0x76, 0x69, 0x76, 0x65, 0x72, 0x72, 0x61, 0x20, 0x61, 0x63, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x71, 0x75, 0x61, 0x74, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x6f, 0x2e, 0x20, 0x53, 0x65, 0x64, 0x20, 0x6c, 0x6f, 0x62, 0x6f, 0x72, 0x74, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x64, 0x75, 0x6d, 0x20, 0x66, 0x61, 0x63, 0x69, 0x6c, 0x69, 0x73, 0x69, 0x73, 0x2e, 0x20, 0x53, 0x65, 0x64, 0x20, 0x65, 0x75, 0x69, 0x73, 0x6d, 0x6f, 0x64, 0x20, 0x65, 0x73, 0x74, 0x20, 0x6d, 0x61, 0x67, 0x6e, 0x61, 0x2c, 0x20, 0x61, 0x74, 0x20, 0x69, 0x61, 0x63, 0x75, 0x6c, 0x69, 0x73, 0x20, 0x6e, 0x69, 0x73, 0x69, 0x20, 0x6d, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x20, 0x61, 0x2e, 0x20, 0x4d, 0x61, 0x65, 0x63, 0x65, 0x6e, 0x61, 0x73, 0x20, 0x6e, 0x65, 0x63, 0x20, 0x64, 0x69, 0x61, 0x6d, 0x20, 0x61, 0x75, 0x67, 0x75, 0x65, 0x2e, 0x20, 0x50, 0x68, 0x61, 0x73, 0x65, 0x6c, 0x6c, 0x75, 0x73, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x74, 0x70, 0x61, 0x74, 0x20, 0x6d, 0x61, 0x74, 0x74, 0x69, 0x73, 0x20, 0x6e, 0x69, 0x73, 0x69, 0x2c, 0x20, 0x65, 0x75, 0x20, 0x73, 0x61, 0x67, 0x69, 0x74, 0x74, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x69, 0x6d, 0x20, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x20, 0x76, 0x69, 0x74, 0x61, 0x65, 0x2e, 0x20, 0x41, 0x6c, 0x69, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x20, 0x61, 0x6e, 0x74, 0x65, 0x20, 0x66, 0x69, 0x6e, 0x69, 0x62, 0x75, 0x73, 0x2c, 0x20, 0x62, 0x69, 0x62, 0x65, 0x6e, 0x64, 0x75, 0x6d, 0x20, 0x6c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x65, 0x74, 0x2c, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x20, 0x6c, 0x69, 0x62, 0x65, 0x72, 0x6f, 0x2e, 0x20, 0x53, 0x65, 0x64, 0x20, 0x65, 0x75, 0x2e},
		},
		"kind_string": {
			golang:  G(testString),
			encoded: []byte{0x74, 0x65, 0x73, 0x74, stringEnd},
			tokens:  []Token{{A: TokenString, Data: testString}},
		},

		"pointer": {
			golang:  &testString,
			encoded: []byte{0x74, 0x65, 0x73, 0x74, stringEnd},
			tokens:  []Token{{A: TokenString, Data: testString}},
		},

		"true": {
			golang:  true,
			encoded: []byte{boolTrue},
			tokens:  []Token{{A: tokenTrue}},
		},
		"false": {
			golang:  false,
			encoded: []byte{boolFalse},
			tokens:  []Token{{A: tokenFalse}},
		},

		"int": {
			golang:  5,
			encoded: []byte{0xa5},
			tokens:  []Token{{A: tokenInt, Data: 5}},
		},
		"int8":  {golang: int8(8), encoded: []byte{0xa8}},
		"int16": {golang: int16(16), encoded: []byte{0xbb, 0x10}},
		"int32": {golang: int32(32), encoded: []byte{0xbb, 0x20}},
		"int64": {golang: int64(64), encoded: []byte{0xbb, 0xc0, 0x0}},

		"uint": {
			golang:  uint(5),
			encoded: []byte{0xa5},
			tokens:  []Token{{A: tokenInt, Data: 5}},
		},
		"uint8":  {golang: uint8(8), encoded: []byte{0xa8}},
		"uint16": {golang: uint16(16), encoded: []byte{0xbb, 0x10}},
		"uint32": {golang: uint32(32), encoded: []byte{0xbb, 0x20}},
		"uint64": {golang: uint64(64), encoded: []byte{0xbb, 0x40}},

		"slice": {
			golang:  []interface{}{testString, true},
			encoded: []byte{listStart, 0x74, 0x65, 0x73, 0x74, stringEnd, boolTrue, listEnd},
			tokens:  []Token{{A: tokenListStart}, {A: TokenString, Data: testString}, {A: tokenTrue}, {A: tokenListEnd}},
		},
		//"typed_array": {
		//	golang: []int{10, 500},
		//},
		"byte_slice": {
			golang:  []byte{1, 30},
			encoded: []byte{listStart, 0xa1, 0xbb, 0x1e, listEnd},
		},

		"array": {
			golang:  [2]bool{false, true},
			encoded: []byte{listStart, boolFalse, boolTrue, listEnd},
			tokens:  []Token{{A: tokenListStart}, {A: tokenFalse}, {A: tokenTrue}, {A: tokenListEnd}},
		},

		//"map": {
		//	golang:  map[string]string{"a": "b"},
		//	encoded: []byte{dictStart, 0x62, stringEnd, 0x61, stringEnd, dictEnd},
		//	tokens:  []Token{{A: tokenDictStart}, {A: TokenString, Data: []byte{0x62}}, {A: TokenString, Data: []byte{0x61}}, {A: tokenDictEnd}},
		//},
	}
)

func TestWrite(t *testing.T) {
	for testCase, tt := range tests {
		t.Run(testCase, func(t *testing.T) {
			var writer bytes.Buffer

			err := (Encoder{}).Write(&writer, tt.golang)

			assert.Equal(t, tt.encoded, writer.Bytes())
			assert.Nil(t, err)
		})
	}
}

func BenchmarkWrite(b *testing.B) {
	for testCase, tt := range tests {
		var writer DummyWriter
		var encoder Encoder

		b.Run(testCase, func(b *testing.B) {
			b.ReportAllocs()

			for i := 0; i < b.N; i++ {
				if err := encoder.Write(&writer, tt.golang); err != nil {
					b.Fatal(err)
				}
			}
		})
	}
}

type DummyWriter struct{}

func (d DummyWriter) Write(_ []byte) (int, error) {
	return 0, nil
}
