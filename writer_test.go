package muon

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
)

type G string

var (
	testString     = "test"
	testLongString = "test Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce mi mauris, fringilla a gravida ac, vulputate vitae dui. Proin rhoncus ante vitae purus mollis, id hendrerit tellus tempor. Aliquam ut ex nibh. Aenean quis quam eu purus scelerisque viverra ac consequat justo. Sed lobortis interdum facilisis. Sed euismod est magna, at iaculis nisi mollis a. Maecenas nec diam augue. Phasellus volutpat mattis nisi, eu sagittis enim tempor vitae. Aliquam sit amet ante finibus, bibendum lorem et, porta libero. Sed eu."

	tests = map[string]struct {
		golang  interface{}
		encoded []byte
		tokens  []Token
	}{
		"nil": {
			golang:  nil,
			encoded: []byte{nilValue},
			tokens:  []Token{{A: tokenNil}},
		},
		"string_empty": {
			golang:  "",
			encoded: []byte{stringEnd},
			tokens:  []Token{{A: TokenString, Data: ""}},
		},
		"string": {
			golang:  testString,
			encoded: []byte{0x74, 0x65, 0x73, 0x74, stringEnd},
			tokens:  []Token{{A: TokenString, Data: testString}},
		},
		"string_with_zero": {
			golang:  "te" + string([]byte{stringEnd}) + "st",
			encoded: []byte{stringStart, 0x5, 0x74, 0x65, 0x0, 0x73, 0x74},
			tokens:  []Token{{A: TokenString, Data: "te" + string([]byte{stringEnd}) + "st"}},
		},
		"long_string": {
			golang:  testLongString,
			encoded: []byte{stringStart, 0x86, 0x4, 0x74, 0x65, 0x73, 0x74, 0x20, 0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x2e, 0x20, 0x46, 0x75, 0x73, 0x63, 0x65, 0x20, 0x6d, 0x69, 0x20, 0x6d, 0x61, 0x75, 0x72, 0x69, 0x73, 0x2c, 0x20, 0x66, 0x72, 0x69, 0x6e, 0x67, 0x69, 0x6c, 0x6c, 0x61, 0x20, 0x61, 0x20, 0x67, 0x72, 0x61, 0x76, 0x69, 0x64, 0x61, 0x20, 0x61, 0x63, 0x2c, 0x20, 0x76, 0x75, 0x6c, 0x70, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x76, 0x69, 0x74, 0x61, 0x65, 0x20, 0x64, 0x75, 0x69, 0x2e, 0x20, 0x50, 0x72, 0x6f, 0x69, 0x6e, 0x20, 0x72, 0x68, 0x6f, 0x6e, 0x63, 0x75, 0x73, 0x20, 0x61, 0x6e, 0x74, 0x65, 0x20, 0x76, 0x69, 0x74, 0x61, 0x65, 0x20, 0x70, 0x75, 0x72, 0x75, 0x73, 0x20, 0x6d, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x2c, 0x20, 0x69, 0x64, 0x20, 0x68, 0x65, 0x6e, 0x64, 0x72, 0x65, 0x72, 0x69, 0x74, 0x20, 0x74, 0x65, 0x6c, 0x6c, 0x75, 0x73, 0x20, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x2e, 0x20, 0x41, 0x6c, 0x69, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x75, 0x74, 0x20, 0x65, 0x78, 0x20, 0x6e, 0x69, 0x62, 0x68, 0x2e, 0x20, 0x41, 0x65, 0x6e, 0x65, 0x61, 0x6e, 0x20, 0x71, 0x75, 0x69, 0x73, 0x20, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x65, 0x75, 0x20, 0x70, 0x75, 0x72, 0x75, 0x73, 0x20, 0x73, 0x63, 0x65, 0x6c, 0x65, 0x72, 0x69, 0x73, 0x71, 0x75, 0x65, 0x20, 0x76, 0x69, 0x76, 0x65, 0x72, 0x72, 0x61, 0x20, 0x61, 0x63, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x71, 0x75, 0x61, 0x74, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x6f, 0x2e, 0x20, 0x53, 0x65, 0x64, 0x20, 0x6c, 0x6f, 0x62, 0x6f, 0x72, 0x74, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x64, 0x75, 0x6d, 0x20, 0x66, 0x61, 0x63, 0x69, 0x6c, 0x69, 0x73, 0x69, 0x73, 0x2e, 0x20, 0x53, 0x65, 0x64, 0x20, 0x65, 0x75, 0x69, 0x73, 0x6d, 0x6f, 0x64, 0x20, 0x65, 0x73, 0x74, 0x20, 0x6d, 0x61, 0x67, 0x6e, 0x61, 0x2c, 0x20, 0x61, 0x74, 0x20, 0x69, 0x61, 0x63, 0x75, 0x6c, 0x69, 0x73, 0x20, 0x6e, 0x69, 0x73, 0x69, 0x20, 0x6d, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x20, 0x61, 0x2e, 0x20, 0x4d, 0x61, 0x65, 0x63, 0x65, 0x6e, 0x61, 0x73, 0x20, 0x6e, 0x65, 0x63, 0x20, 0x64, 0x69, 0x61, 0x6d, 0x20, 0x61, 0x75, 0x67, 0x75, 0x65, 0x2e, 0x20, 0x50, 0x68, 0x61, 0x73, 0x65, 0x6c, 0x6c, 0x75, 0x73, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x74, 0x70, 0x61, 0x74, 0x20, 0x6d, 0x61, 0x74, 0x74, 0x69, 0x73, 0x20, 0x6e, 0x69, 0x73, 0x69, 0x2c, 0x20, 0x65, 0x75, 0x20, 0x73, 0x61, 0x67, 0x69, 0x74, 0x74, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x69, 0x6d, 0x20, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x20, 0x76, 0x69, 0x74, 0x61, 0x65, 0x2e, 0x20, 0x41, 0x6c, 0x69, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x20, 0x61, 0x6e, 0x74, 0x65, 0x20, 0x66, 0x69, 0x6e, 0x69, 0x62, 0x75, 0x73, 0x2c, 0x20, 0x62, 0x69, 0x62, 0x65, 0x6e, 0x64, 0x75, 0x6d, 0x20, 0x6c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x65, 0x74, 0x2c, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x20, 0x6c, 0x69, 0x62, 0x65, 0x72, 0x6f, 0x2e, 0x20, 0x53, 0x65, 0x64, 0x20, 0x65, 0x75, 0x2e},
			tokens:  []Token{{A: TokenString, Data: testLongString}},
		},
		"kind_string": {
			golang:  G(testString),
			encoded: []byte{0x74, 0x65, 0x73, 0x74, stringEnd},
			tokens:  []Token{{A: TokenString, Data: testString}},
		},

		"pointer": {
			golang:  &testString,
			encoded: []byte{0x74, 0x65, 0x73, 0x74, stringEnd},
			tokens:  []Token{{A: TokenString, Data: testString}},
		},

		"true": {
			golang:  true,
			encoded: []byte{boolTrue},
			tokens:  []Token{{A: tokenTrue}},
		},
		"false": {
			golang:  false,
			encoded: []byte{boolFalse},
			tokens:  []Token{{A: tokenFalse}},
		},

		"int": {
			golang:  5,
			encoded: []byte{0xa5},
			tokens:  []Token{{A: TokenNumber, Data: 5}},
		},
		"int8": {
			golang:  int8(8),
			encoded: []byte{0xa8},
			tokens:  []Token{{A: TokenNumber, Data: 8}},
		},
		"int16": {
			golang:  int16(16),
			encoded: []byte{typeInt16, 0x10},
		},
		"int32": {
			golang:  int32(32),
			encoded: []byte{typeInt32, 0x20},
		},
		"int64": {
			golang:  int64(64),
			encoded: []byte{typeInt64, 0xc0, 0x0},
		},

		"uint": {
			golang:  uint(5),
			encoded: []byte{0xa5},
			tokens:  []Token{{A: TokenNumber, Data: 5}},
		},
		"uint8": {
			golang:  uint8(8),
			encoded: []byte{0xa8},
			tokens:  []Token{{A: TokenNumber, Data: 8}},
		},
		"uint16": {
			golang:  uint16(16),
			encoded: []byte{typeUint16, 0x10},
		},
		"uint32": {
			golang:  uint32(32),
			encoded: []byte{typeUint32, 0x20},
		},
		"uint64": {
			golang:  uint64(64),
			encoded: []byte{typeUint64, 0x40},
		},

		"slice": {
			golang:  []interface{}{testString, true},
			encoded: []byte{listStart, 0x74, 0x65, 0x73, 0x74, stringEnd, boolTrue, listEnd},
			tokens:  []Token{{A: tokenListStart}, {A: TokenString, Data: testString}, {A: tokenTrue}, {A: tokenListEnd}},
		},
		"byte_slice": {
			golang:  []byte{0x1, 0x30},
			encoded: []byte{listStart, typeUint8, 2, 0x1, 0x30, listEnd},
			tokens:  []Token{{A: tokenListStart}, {A: TokenNumber, Data: 0x1}, {A: TokenNumber, Data: 0x30}, {A: tokenListEnd}},
		},

		"array": {
			golang:  [2]bool{false, true},
			encoded: []byte{listStart, boolFalse, boolTrue, listEnd},
			tokens:  []Token{{A: tokenListStart}, {A: tokenFalse}, {A: tokenTrue}, {A: tokenListEnd}},
		},
		"map": {
			golang:  map[string]string{"a": "b"},
			encoded: []byte{dictStart, 0x61, stringEnd, 0x62, stringEnd, dictEnd},
			tokens:  []Token{{A: tokenDictStart}, {A: TokenString, Data: "a"}, {A: TokenString, Data: "b"}, {A: tokenDictEnd}},
		},
	}
)

func TestWrite(t *testing.T) {
	for testCase, tt := range tests {
		t.Run(testCase, func(t *testing.T) {
			var writer bytes.Buffer

			err := NewEncoder(&writer).Write(tt.golang)

			assert.Equal(t, tt.encoded, writer.Bytes())
			assert.Nil(t, err)
		})
	}
}

func BenchmarkWrite(b *testing.B) {
	for testCase, tt := range tests {
		var writer DummyWriter
		var encoder = NewEncoder(&writer)

		b.Run(testCase, func(b *testing.B) {
			b.ReportAllocs()

			for i := 0; i < b.N; i++ {
				if err := encoder.Write(tt.golang); err != nil {
					b.Fatal(err)
				}
			}

		})
	}
}

type DummyWriter struct{}

func (d DummyWriter) Write(in []byte) (int, error) {
	return len(in), nil
}
